name: "Version Bump and Release"
description: "Bumps the version, creates a tag, and creates a GitHub release with AI-generated release notes using Azure OpenAI"

inputs:
  draft:
    description: "Set the release as a draft"
    required: false
    default: "true"
  prerelease:
    description: "Mark the release as a pre-release"
    required: false
    default: "true"
  azure_openai_endpoint:
    description: "Azure OpenAI endpoint URL (e.g., https://your-resource.openai.azure.com/)"
    required: true
  azure_openai_deployment_name:
    description: "Azure OpenAI model deployment name"
    required: true
  azure_openai_api_key:
    description: "Azure OpenAI key (optional if using Azure RBAC with GitHub OIDC federation)"
    required: false
  azure_client_id:
    description: "Azure Client ID for OIDC federation"
    required: false
  azure_tenant_id:
    description: "Azure Tenant ID for OIDC federation"
    required: false
  azure_subscription_id:
    description: "Azure Subscription ID for OIDC federation"
    required: false
  azure_openai_api_version:
    description: "Azure OpenAI API version"
    required: true
  temperature:
    description: "Temperature for text generation (0.0-2.0)"
    required: false
    default: "0.2"
  max_tokens:
    description: "Maximum number of tokens in the response"
    required: false
    default: "4000"
  top_p:
    description: >-
      Controls diversity of language model output. Lower values (e.g., 0.1) make responses more focused and deterministic,
      while higher values (e.g., 0.9) allow more diverse and creative responses. Default 1.0 uses standard sampling.
    required: false
    default: "1.0"
  frequency_penalty:
    description: >-
      Reduces word repetition by penalizing tokens based on their frequency in the text. Positive values decrease
      repetition and encourage exploration of new topics, while negative values may increase focus on key themes.
      Range: -2.0 (may increase repetition) to 2.0 (strongly discourages repetition).
    required: false
    default: "0.1"
  presence_penalty:
    description: >-
      Influences topic diversity by penalizing tokens that have appeared at all in the text. Positive values encourage
      the model to discuss new topics, while negative values increase focus on existing topics. Range: -2.0 (may
      increase focus on existing topics) to 2.0 (strongly encourages new topics).
    required: false
    default: "0.1"
  response_format:
    description: "Response format (text or json_object)"
    required: false
    default: "text"
  seed:
    description: "Random number seed for deterministic outputs"
    required: false
    default: ""
  release_prefix:
    description: "Prefix for release titles"
    required: false
    default: ""
  validate_version_history:
    description: "Enable version history validation"
    required: false
    default: "true"
  closing_note:
    description: "Provide a standarized closing note for all Release Notes"
    required: false
    default: "\n\n## Closing Note\nA heartfelt thank you to all contributors: $contributors.\n"
  append_context:
    description: "Additional context to provide to Azure OpenAI for release notes generation."
    required: false
    default: ""
  default_bump_level:  
    description: "Specifies the default version bump level. Valid options are '', 'major', 'minor', or 'patch'. Setting this ensures a new version is created even if commit messages lack relevant keywords."  
    required: false  

outputs:
  version:
    description: "The new version number that was created"
  previous_version:
    description: "The previous version used for comparison"
  bump_level:
    description: "The type of version bump performed (major, minor, patch, or initial)"

runs:  
  using: "composite"  
  steps:  
    - name: Validate Inputs  
      shell: bash  
      run: |  
        if [ -z "${{ inputs.azure_openai_endpoint }}" ]; then  
          echo "Error: azure_openai_endpoint is required"  
          exit 1  
        fi  
        if [[ "${{ inputs.azure_openai_endpoint }}" != "https://"* ]]; then  
          echo "Error: azure_openai_endpoint must start with https://"  
          exit 1  
        fi  
        # Validate the default_bump_level
        valid_bump_levels=("major" "minor" "patch" "")  
        if [[ ! " ${valid_bump_levels[@]} " =~ " ${{ inputs.default_bump_level }} " ]]; then  
          echo "Error: Invalid default_bump_level value. Must be one of: 'major', 'minor', 'patch', or empty."  
          exit 1  
        fi  
  
    - name: Determine Version and Comparison Base  
      id: version_info  
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
      run: |  
        set -e  
  
        # Function to get the latest tag on the current branch  
        get_latest_branch_tag() {  
          git describe --tags --abbrev=0 --match "v[0-9]*" 2>/dev/null || echo "v0.0.0"  
        }  
  
        # Get the latest tag in the current branch  
        base_tag=$(get_latest_branch_tag)
        echo "Current base tag: $base_tag"  
  
        # Parse version components  
        if [[ $base_tag == "v0.0.0" ]]; then
          major=0
          minor=0
          patch=0
        else
          major=$(echo $base_tag | sed 's/v//' | cut -d. -f1)
          minor=$(echo $base_tag | cut -d. -f2)
          patch=$(echo $base_tag | cut -d. -f3 | cut -d- -f1)
        fi
  
        # Check the event type
        if [[ "${{ github.event_name }}" == "pull_request" ]]; then
          # For pull request event
          echo "Workflow triggered by a Pull Request. Fetching commits from the PR."

          # Fetch the list of commits in the pull request
          pull_request_commits=$(gh api repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/commits | jq -r '.[].commit.message')

          # Extract the last commit message
          commit_message=$(echo "$pull_request_commits" | tail -n 1 | tr '[:upper:]' '[:lower:]')

          echo "Commit message from Pull Request: $commit_message"
        else
          # For push event
          echo "Workflow triggered by a direct push. Fetching the latest commit message from the branch."

          # Ensure the branch history is fully fetched
          git fetch origin

          # Get the last commit message on the head of the branch
          commit_message=$(git log -1 --pretty=%B | tr '[:upper:]' '[:lower:]')

          echo "Commit message from Push: $commit_message"
        fi

        # Debugging: Print the fetched commit message
        echo "Fetched commit message: '$commit_message'"

        # Initialize bump_level and pre_release_type
        bump_level=""  
        pre_release_type=""  

        # Debugging: Check keyword matching
        echo "Checking commit message for keywords..."

        # Determine bump type priority: major > minor > patch
        if [[ "$commit_message" == *"breaking change:"* ]] || [[ "$commit_message" == *"major:"* ]]; then  
          bump_level="major"  
          echo "Detected bump level: major"
        elif [[ "$commit_message" == *"feat:"* ]] || [[ "$commit_message" == *"minor:"* ]]; then  
          bump_level="minor"  
          echo "Detected bump level: minor"
        elif [[ "$commit_message" == *"fix:"* ]] || [[ "$commit_message" == *"patch:"* ]]; then  
          bump_level="patch"  
          echo "Detected bump level: patch"
        else
          echo "No matching keywords found in the commit message."
        fi

        # Debugging: Pre-release type detection
        echo "Checking commit message for pre-release keywords..."
        if [[ "$commit_message" == *"alpha:"* ]]; then  
          pre_release_type="alpha"  
          echo "Detected pre-release type: alpha"
        elif [[ "$commit_message" == *"beta:"* ]]; then  
          pre_release_type="beta"  
          echo "Detected pre-release type: beta"
        elif [[ "$commit_message" == *"rc:"* ]]; then  
          pre_release_type="rc"  
          echo "Detected pre-release type: rc"
        elif [[ "$commit_message" == *"preview:"* ]]; then  
          pre_release_type="preview"  
          echo "Detected pre-release type: preview"
        fi

        # If no bump_level is found, use default or skip new release
        if [[ -z "$bump_level" && -n "${{ inputs.default_bump_level }}" ]]; then
          bump_level="${{ inputs.default_bump_level }}"
        elif [[ -z "$bump_level" && -z "${{ inputs.default_bump_level }}" ]]; then
          echo "No bump level determined from commit message and no default_bump_level provided. The next steps will be skipped as no Release Notes should be generated."
          skip_release_notes=true
          echo "skip_release_notes=true" >> $GITHUB_OUTPUT
        fi

        # If skip_release_notes is not set, proceed with version calculation

        if [[ -z "$skip_release_notes" ]]; then
          echo "No bump level detected; using default bump level: $bump_level"

          # Debugging: Display final values
          echo "Final bump level: $bump_level"
          echo "Final pre-release type: $pre_release_type"

          # Calculate new version
          new_major=$major  
          new_minor=$minor  
          new_patch=$patch  

          # Apply version bump
          if [[ "$bump_level" == "major" ]]; then  
            new_major=$((major + 1))  
            new_minor=0  
            new_patch=0  
          elif [[ "$bump_level" == "minor" ]]; then  
            new_minor=$((minor + 1))  
            new_patch=0  
          elif [[ "$bump_level" == "patch" ]]; then  
            new_patch=$((patch + 1))  
          fi

          # Handle pre-release versioning
          if [[ -n "$pre_release_type" ]]; then  
            current_pre_release=$(git tag --sort=-v:refname | grep "^v${new_major}.${new_minor}.${new_patch}-${pre_release_type}" | head -n 1 || echo "")  
            if [[ -z "$current_pre_release" ]]; then  
              new_version="v${new_major}.${new_minor}.${new_patch}-${pre_release_type}.1"  
            else  
              current_number=$(echo $current_pre_release | awk -F- '{print $2}' | cut -d'.' -f2)  
              new_version="v${new_major}.${new_minor}.${new_patch}-${pre_release_type}.$((current_number + 1))"  
            fi  
          else  
            # Regular versioning without pre-release  
            new_version="v${new_major}.${new_minor}.${new_patch}"  
          fi  

          # Output values for other steps  
          {  
            echo "new_version=$new_version"  
            echo "previous_version=$base_tag"  
            echo "bump_level=${bump_level:-$pre_release_type}"
            echo "pre_release_type=$pre_release_type"  
          } >> "$GITHUB_OUTPUT"
        fi

    - name: Set up Git
      if: ${{ steps.version_info.outputs.skip_release_notes != 'true' }}
      shell: bash
      env:
        GIT_USER_NAME: "github-actions[bot]"
        GIT_USER_EMAIL: "github-actions[bot]@users.noreply.github.com"
      run: |
        git config --global user.name "$GIT_USER_NAME"
        git config --global user.email "$GIT_USER_EMAIL"

    - name: Tag new version
      if: ${{ steps.version_info.outputs.skip_release_notes != 'true' }}
      shell: bash
      run: |
        set -e
        git tag -a "${{ steps.version_info.outputs.new_version }}" -m "Release ${{ steps.version_info.outputs.new_version }}"
        git push origin "${{ steps.version_info.outputs.new_version }}"

    - name: Azure login
      if: ${{ !inputs.azure_openai_api_key && steps.version_info.outputs.skip_release_notes != 'true' }}
      uses: azure/login@v2
      with:
        client-id: ${{ inputs.azure_client_id }}
        tenant-id: ${{ inputs.azure_tenant_id }}
        subscription-id: ${{ inputs.azure_subscription_id }}

    - name: Configure Azure OpenAI
      if: ${{ steps.version_info.outputs.skip_release_notes != 'true' }}
      id: azure_openai_config
      shell: bash
      env:
        AZURE_OPENAI_ENDPOINT: ${{ inputs.azure_openai_endpoint }}
        AZURE_OPENAI_API_KEY: ${{ inputs.azure_openai_api_key }}
        AZURE_OPENAI_DEPLOYMENT_NAME: ${{ inputs.azure_openai_deployment_name }}
        AZURE_OPENAI_API_VERSION: ${{ inputs.AZURE_OPENAI_API_VERSION }}
      run: |
        echo "Debug: Checking Azure OpenAI configuration"
        echo "Endpoint: ${AZURE_OPENAI_ENDPOINT}"
        echo "Deployment: ${AZURE_OPENAI_DEPLOYMENT_NAME}"
        echo "API Version: ${AZURE_OPENAI_API_VERSION}"

        # Authentication
        if [ -n "$AZURE_OPENAI_API_KEY" ] && [ "$AZURE_OPENAI_API_KEY" != "" ]; then
          echo "Debug: Using API key authentication"
          auth_header="api-key: $AZURE_OPENAI_API_KEY"
        else
          echo "Debug: Using managed identity authentication"
          token=$(az account get-access-token --resource https://cognitiveservices.azure.com/ --query accessToken -o tsv)
          if [ $? -ne 0 ]; then
            echo "Error: Failed to get Azure token"
            exit 1
          fi
          auth_header="Authorization: Bearer $token"
        fi

        # Export auth header for next steps
        echo "auth_header=$auth_header" >> $GITHUB_OUTPUT
        echo "Debug: Azure OpenAI configuration complete"

    - name: Extract Contributors
      if: ${{ steps.version_info.outputs.skip_release_notes != 'true' }}
      id: contributors
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        # Extract contributors' GitHub IDs
        contributors=$(gh api repos/${{ github.repository }}/commits --paginate \
          | jq -r '.[].author | select(. != null) | "@\(.login)"' \
          | sort | uniq \
          | jq -Rs 'split("\n") | map(select(. != "")) | join(", ")')
        echo "Contributors identified: $contributors"
        echo "contributors=$contributors" >> $GITHUB_OUTPUT


    - name: Generate Release Notes
      if: ${{ steps.version_info.outputs.skip_release_notes != 'true' }}
      id: release_notes
      shell: bash
      env:
        AZURE_OPENAI_ENDPOINT: ${{ inputs.azure_openai_endpoint }}
        AZURE_OPENAI_DEPLOYMENT_NAME: ${{ inputs.azure_openai_deployment_name }}
        AZURE_OPENAI_API_VERSION: ${{ inputs.AZURE_OPENAI_API_VERSION }}
        TEMPERATURE: ${{ inputs.temperature }}
        MAX_TOKENS: ${{ inputs.max_tokens }}
        TOP_P: ${{ inputs.top_p }}
        FREQUENCY_PENALTY: ${{ inputs.frequency_penalty }}
        PRESENCE_PENALTY: ${{ inputs.presence_penalty }}
        RESPONSE_FORMAT: ${{ inputs.response_format }}
        SEED: ${{ inputs.seed }}
        AUTH_HEADER: ${{ steps.azure_openai_config.outputs.auth_header }}
      run: |
        latest_version="${{ steps.version_info.outputs.new_version }}"
        previous_version="${{ steps.version_info.outputs.previous_version }}"
        bump_level="${{ steps.version_info.outputs.bump_level }}"
        contributors="${{ steps.contributors.outputs.contributors }}"
        append_context="${{ inputs.append_context }}"

        echo "Debug: Git Information"
        echo "Latest version: $latest_version"
        echo "Previous version: $previous_version"
        echo "Bump type: $bump_level"
        
        # Get the first commit hash
        first_commit=$(git rev-list --max-parents=0 HEAD)
        echo "First commit: $first_commit"
        
        # Handle first release differently
        if [[ "$previous_version" == "v0.0.0" ]]; then
          echo "Initial release - getting all changes since first commit"
          # Get changes from first commit to current HEAD
          git_diff=$(git diff $first_commit..HEAD | base64)
          # Get all commit messages from first commit
          commit_messages=$(git log --format="%h %s" $first_commit..HEAD | base64)
          # Get all PR titles from first commit
          pr_titles=$(git log --pretty=format:"%s" $first_commit..HEAD --grep "Merge pull request" | base64)
        else
          # For subsequent releases, compare with previous tag
          echo "Regular release - comparing with previous tag"
          git_diff=$(git diff $previous_version..HEAD | base64)
          commit_messages=$(git log $previous_version..HEAD --format="%h %s" | base64)
          pr_titles=$(git log $previous_version..HEAD --pretty=format:"%s" --grep "Merge pull request" | base64)
        fi

        echo -e "\nDebug: Prepared Data"
        echo "git_diff (Base64): ${git_diff:0:100}..." # Show first 100 chars for debugging
        echo "commit_messages (Base64): ${commit_messages:0:100}..." # Show first 100 chars for debugging
        echo "pr_titles (Base64): ${pr_titles:0:100}..." # Show first 100 chars for debugging

        # Prepare the request body dynamically based on inputs
        request_body=$(jq -n \
          --arg latest "$latest_version" \
          --arg previous "$previous_version" \
          --arg diff "$git_diff" \
          --arg commits "$commit_messages" \
          --arg prs "$pr_titles" \
          --arg temp "$TEMPERATURE" \
          --arg max "$MAX_TOKENS" \
          --arg top "$TOP_P" \
          --arg freq "$FREQUENCY_PENALTY" \
          --arg pres "$PRESENCE_PENALTY" \
          --arg append "$APPEND_CONTEXT" \
          '{
            messages: [
              {
                role: "system",
                content: "You are a professional technical writer and code expert specializing in generating concise and consistent release notes for software releases based on inputs from Base64-encoded git diff, commit messages, pull-request messages, and titles. Decode the Base64 strings before analyzing it."
              },
              {
                role: "user",
                content: "Generate a software release note based on a deep code and feature analyze of this full content. By default Include:\n1. A title: # Relase Note, do not include version information as this will be added automaticly within GitHub.\n2. A top section ##Summary.\n3. Sections for ### New Features, ### Bug Fixes and ### Improvements if relevant, this default structure can be overriden by the Additional context below.\n- Additional context: \($append)\n- Git diff base64: \($diff)\n- Commit messages base64: \($commits)\n- PR titles base64: \($prs)"
              }
            ],
            temperature: ($temp|tonumber),
            max_tokens: ($max|tonumber),
            top_p: ($top|tonumber),
            frequency_penalty: ($freq|tonumber),
            presence_penalty: ($pres|tonumber)
          }')

        echo "Debug: Request body prepared"
        echo "$request_body" | jq '.'

        # Add response format if specified and not default
        if [ -n "$RESPONSE_FORMAT" ] && [ "$RESPONSE_FORMAT" != "text" ]; then
          request_body=$(echo "$request_body" | jq --arg fmt "$RESPONSE_FORMAT" '. + {response_format: {type: $fmt}}')
        fi

        # Add seed if specified
        if [ -n "$SEED" ]; then
          request_body=$(echo "$request_body" | jq --arg seed "$SEED" '. + {seed: ($seed|tonumber)}')
        fi

        echo "Debug: Request body prepared after extra properties"
        echo "$request_body" | jq '.'

        response=$(curl -s -X POST "$AZURE_OPENAI_ENDPOINT/openai/deployments/$AZURE_OPENAI_DEPLOYMENT_NAME/chat/completions?api-version=$AZURE_OPENAI_API_VERSION" \
          -H "Content-Type: application/json" \
          -H "$AUTH_HEADER" \
          -d "$request_body")

        echo "Debug: Full API Response:"
        echo "$response" | jq '.'

        if ! echo "$response" | jq -r '.choices[0].message.content' > release_notes.md; then
          echo "Error: Failed to extract content from response"
          echo "Response structure:"
          echo "$response" | jq '.'
          exit 1
        fi

        echo "Debug: Generated Release Notes:"
        cat release_notes.md

    - name: Append Contributors to Release Notes
      if: ${{ inputs.closing_note != '' && steps.version_info.outputs.skip_release_notes != 'true' }}
      id: append_contributors
      shell: bash
      run: |
        # Retrieve contributors from previous step
        contributors="${{ steps.contributors.outputs.contributors }}"

        # Append the closing note to release notes
        echo -e "${{ inputs.closing_note }}" >> release_notes.md

        # Debug: Display updated release notes
        echo "Debug: Updated Release Notes:"
        cat release_notes.md

    - name: Create GitHub Release
      if: ${{ steps.version_info.outputs.skip_release_notes != 'true' }}
      shell: bash
      env:
        GITHUB_TOKEN: ${{ github.token }}
        RELEASE_PREFIX: ${{ inputs.release_prefix }}
      run: |
        echo "Debug: Creating GitHub release"
        if [ ! -f release_notes.md ]; then
          echo "Error: release_notes.md file not found"
          exit 1
        fi

        release_body=$(cat release_notes.md | jq -Rsa .)
        
        echo "Debug: Creating release with:"
        echo "Tag: ${{ steps.version_info.outputs.new_version }}"
        echo "Name: $RELEASE_PREFIX ${{ steps.version_info.outputs.new_version }}"
        
        response=$(curl -v -X POST "https://api.github.com/repos/${{ github.repository }}/releases" \
          -H "Authorization: token $GITHUB_TOKEN" \
          -H "Content-Type: application/json" \
          -H "Accept: application/vnd.github.v3+json" \
          -d "{
            \"tag_name\": \"${{ steps.version_info.outputs.new_version }}\",
            \"name\": \"$RELEASE_PREFIX ${{ steps.version_info.outputs.new_version }}\",
            \"body\": $release_body,
            \"draft\": ${{ inputs.draft }},
            \"prerelease\": ${{ inputs.prerelease }}
          }")

        if ! echo "$response" | jq -e .id > /dev/null 2>&1; then
          echo "Error: Failed to create release"
          echo "Response:"
          echo "$response" | jq '.'
          exit 1
        fi

        echo "Success: Release created successfully"